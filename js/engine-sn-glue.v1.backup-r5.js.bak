(function (w, d) {
  "use strict";

  function q(s){ return d.querySelector(s); }
  function qa(s){ return d.querySelectorAll(s); }

  // Só ativa se a página tiver sinais do Validador Motor
  function isMotorPage(){
    return !!(q("#engine-picker-hook") || q("#btn-validate-engine") || q("#engine-result-hook"));
  }

  const FIELD_HTML = [
    '<div id="engine-serial-field-hook" class="form-row">',
    '  <label for="engine-sn-raw">Nº do motor / Engine serial</label>',
    '  <div class="row">',
    '    <input id="engine-sn-raw" type="text" placeholder="Ex.: BAAL-999123, 1B123456" autocomplete="off" />',
    '    <div class="sn-kind">',
    '      <label><input type="radio" name="engine-sn-kind" value="auto" checked> Auto</label>',
    '      <label><input type="radio" name="engine-sn-kind" value="exterior"> Exterior</label>',
    '      <label><input type="radio" name="engine-sn-kind" value="interior"> Interior</label>',
    '    </div>',
    '  </div>',
    '  <small class="muted" id="engine-sn-hints"></small>',
    '</div>'
  ].join("");

  function ensureField(){
    if (!isMotorPage()) return false;
    if (q("#engine-sn-raw")) return true;
    const host = q("#engine-picker-hook") || q("#engine-form") || q("main") || d.body;
    if (!host) return false;
    const wrap = d.createElement("div");
    wrap.innerHTML = FIELD_HTML;
    // inserir mesmo no topo do picker
    host.prepend(wrap.firstChild);
    console.info("[IDMAR] SN field injected into #engine-picker-hook.");
    return true;
  }

  async function runSNCheck(){
    const input = q("#engine-sn-raw"); if (!input) return;
    const sn = (input.value || "").trim();
    const kindEl = q('input[name="engine-sn-kind"]:checked');
    const kind = kindEl ? kindEl.value : "auto";

    const brand  = (q("#engine-brand, #engine-picker-hook select[name='brand']")?.value || "").trim();
    const model  = (q("#engine-model-code, #engine-model")?.value || "").trim();
    const hpRaw  = (q("#engine-hp, input[name='engine-hp']")?.value || "").trim();
    const hp     = hpRaw ? parseInt(hpRaw.replace(/\D+/g,""),10) : null;
    const yearRaw= (q("#engine-year, input[name='engine-year']")?.value || "").trim();
    const year   = yearRaw ? parseInt(yearRaw.replace(/\D+/g,""),10) : null;
    const sel = { brand, model, hp, year };

    const hintsEl = q("#engine-sn-hints");
    if (!sn){
      if (hintsEl) hintsEl.textContent = "";
      // limpa notas
      const box = q("#engine-result-hook") || q("#engine-result") || d.body;
      box?.querySelector('[data-idmar-extra-notes="1"]')?.remove();
      return;
    }

    // parser
    let parsed = w.IDMAR_EngineSN?.parse(sn, brand) || null;

    // Honda: distinguir exterior/interior
    if ((brand||"").toLowerCase()==="honda"){
      const hasPrefix = /^[A-Z0-9]+[-\s]?\d{4,}$/.test(sn) && /[A-Z]/.test(sn.charAt(0));
      if (kind === "exterior" && !hasPrefix) parsed = null;
      if (kind === "interior" && hasPrefix){
        parsed = { brand:"Honda", prefix:null, serial: parseInt(sn.replace(/\D+/g,""),10) || null, source:"interior" };
      }
    }

    const ranges = await w.IDMAR_SerialRangeCheck.loadRanges();
    let res;
    if (parsed && parsed.brand==="Honda" && parsed.source==="interior"){
      res = { ok:true, notes:["ℹ️ Honda (interior): número de bloco interno. Validação por coerência (sem faixa de prefixo)."] };
    } else {
      res = w.IDMAR_SerialRangeCheck.checkAgainstSelection(parsed, sel, ranges);
      if ((brand||"").toLowerCase()==="honda" && kind!=="interior" && parsed && (!parsed.prefix || !parsed.serial)){
        res.notes = (res.notes||[]).concat(["ℹ️ Honda: números exteriores costumam ter prefixo (ex.: BAAL-1234567)."]);
      }
    }

    // hints
    if (hintsEl){
      const bits = [];
      if (parsed?.brand)  bits.push(`brand: ${parsed.brand}`);
      if (parsed?.prefix) bits.push(`prefix: ${parsed.prefix}`);
      if (parsed?.serial) bits.push(`serial: ${parsed.serial}`);
      if ((brand||"").toLowerCase()==="honda") bits.push(`tipo: ${kind}`);
      hintsEl.textContent = bits.join(" · ");
    }

    // render
    if (typeof w.renderEngineResult === "function"){
      w.renderEngineResult(true, res.notes || []);
    } else {
      const box = q("#engine-result-hook") || q("#engine-result") || d.body;
      const old = box.querySelector('[data-idmar-extra-notes="1"]'); if (old) old.remove();
      const ul = d.createElement("ul"); ul.setAttribute("data-idmar-extra-notes","1");
      (res.notes||[]).forEach(n => { const li = d.createElement("li"); li.textContent = n; ul.appendChild(li); });
      box.appendChild(ul);
    }
  }

  function wireEvents(){
    const input = q("#engine-sn-raw");
    if (!input) return;
    input.addEventListener("input", runSNCheck, { passive:true });
    input.addEventListener("blur",  runSNCheck, { passive:true });
    qa('input[name="engine-sn-kind"]').forEach(r => r.addEventListener("change", runSNCheck));
    q("#btn-validate-engine")?.addEventListener("click", runSNCheck);
  }

  function installObserver(){
    // injeta assim que #engine-picker-hook aparecer
    const mo = new MutationObserver(() => {
      if (!isMotorPage()) return;
      if (q("#engine-serial-field-hook") && q("#engine-sn-raw")) return;
      if (q("#engine-picker-hook") || q("#engine-form") || q("#engine-result-hook")){
        if (ensureField()){ wireEvents(); }
      }
    });
    mo.observe(d.documentElement, { childList:true, subtree:true });
  }

  if (d.readyState === "loading"){
    d.addEventListener("DOMContentLoaded", () => {
      if (!isMotorPage()) return;
      ensureField();
      wireEvents();
      installObserver();
    });
  } else {
    if (!isMotorPage()) return;
    ensureField();
    wireEvents();
    installObserver();
  }

  console.info("[IDMAR] Engine SN glue v1 (robusto) carregado.");
})(window, document);
